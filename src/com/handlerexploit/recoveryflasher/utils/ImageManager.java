/*
 *  Copyright (c) 2012 Daniel Huckaby
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.handlerexploit.recoveryflasher.utils;

import java.io.File;
import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.os.Handler;

public class ImageManager {
    
    private static ImageManager sInstance;
    
    private Handler mHandler = new Handler();
    
    private ExecutorService mExecutorService = Executors.newCachedThreadPool();
    
    private Map<File, WeakReference<Bitmap>> mWeakBitmapMap = new HashMap<File, WeakReference<Bitmap>>();
    
    private ImageManager() {
        super();
    }
    
    public static ImageManager getInstance() {
        if (sInstance == null) {
            sInstance = new ImageManager();
        }
        return sInstance;
    }
    
    /**
     * Returns the appropriate {@link Bitmap} through the
     * {@link OnImageRecievedListener} synchronously or asynchronously depending
     * on the state of the internal cache state.
     */
    public void get(final File file, final OnImageRecievedListener onImageRecievedListener) {
        if (file == null || onImageRecievedListener == null) return;
        
        WeakReference<Bitmap> weakBitmap = mWeakBitmapMap.get(file);
        if (weakBitmap != null) {
            Bitmap bitmap = weakBitmap.get();
            if (bitmap != null) {
                onImageRecievedListener.onImageReceived(file, bitmap);
                return;
            }
        }

        mExecutorService.execute(new Runnable() {
            
            @Override
            public void run() {
                /*
                 * BitmapFactory.decodeFile() is surprisingly very stable, even testing loads 1000x normal usage it never caused OOME's.
                 * Although the user experience was trashed because of all the garbage collecting it never ran out of memory.
                 */
                final Bitmap bitmap = BitmapFactory.decodeFile(file.getAbsolutePath());
                mHandler.post(new Runnable() {
                    
                    @Override
                    public void run() {
                        mWeakBitmapMap.put(file, new WeakReference<Bitmap>(bitmap));
                        onImageRecievedListener.onImageReceived(file, bitmap);
                    }
                });
            }
        });
    }
    
    public static interface OnImageRecievedListener {
        public void onImageReceived(File file, Bitmap bitmap);
    }
}